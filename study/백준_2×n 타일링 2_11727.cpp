// N이 1,2,3,4,5일 때 답은 각각 1,1,3,11,21이다.
// dp[0](없는 경우도 1가지의 경우이다.), dp[1], dp[2]의 값 1,1,3을 구해 놓고
// dp[3]부터 dp[N]까지 구한다. dp[4]를 구하는 과정을 예로 들면
// dp[2](길이가 2일 때 만들 수 있는 가장 큰 경우의 수) * 3(dp[2]로 만든 블럭들에 각각 =,||,ㅁ 이 세가지 경우를 곱해준다.)
// 이 경우에는 중간에 교차한 작대기의 개수를 구할 수 없다. (이런 경우 |=|, |ㅁ|)
// 이런 경우는 dp[1] * 2(|=|, |ㅁ| 이 두가지 경우를 곱해준다.)를 해주면 구할 수 있다.
// 이렇게 구한 dp[2]*3 + dp[1]*2가 dp[4]의 값이 된다.
// 인덱스 4를 i로 바꿔 dp[i] = (dp[i - 2] * 3 + dp[i - 3] * 2)
// N번 처리하면 dp[N]에는 길이 N에 대한 가장 많은 경우의 타일링 수가 들어간다.

#include <iostream>
using namespace std;
#define MOD 10007
int N;
int dp[1001] = { 1,1,3 };

int main() {
	cin >> N;
	for (int i = 3; i <= N; i++)
		dp[i] = (dp[i - 2] * 3 + dp[i - 3] * 2) % MOD;
	cout << dp[N];
	return 0;
}